<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Lightcurve MC: lcmc::utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Lightcurve MC
   &#160;<span id="projectnumber">2.3.0</span>
   </div>
   <div id="projectbrief">Lightcurve MC carries out Monte Carlo simulations of statistical light curve analysis.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacelcmc_1_1utils.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lcmc::utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This namespace contains miscellaneous functions for handling generic problems.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcmc_1_1utils_1_1_approx_equal.html">ApproxEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for testing whether two values are approximately equal.  <a href="classlcmc_1_1utils_1_1_approx_equal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abe8f3c1ecc79bfa27e2e6057cc9f5a82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#abe8f3c1ecc79bfa27e2e6057cc9f5a82">isMatrixClose</a> (const gsl_matrix *const a, const gsl_matrix *const b, double tolerance)</td></tr>
<tr class="memdesc:abe8f3c1ecc79bfa27e2e6057cc9f5a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether two matrices have approximately equal elements.  <a href="#abe8f3c1ecc79bfa27e2e6057cc9f5a82">More...</a><br/></td></tr>
<tr class="separator:abe8f3c1ecc79bfa27e2e6057cc9f5a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550c8ecef52e617df1124ecdf12bd4cd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a550c8ecef52e617df1124ecdf12bd4cd">fluxToMag</a> (double flux)</td></tr>
<tr class="memdesc:a550c8ecef52e617df1124ecdf12bd4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for converting fluxes to magnitudes.  <a href="#a550c8ecef52e617df1124ecdf12bd4cd">More...</a><br/></td></tr>
<tr class="separator:a550c8ecef52e617df1124ecdf12bd4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac406632e5ac15061216476af953dbd0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#aac406632e5ac15061216476af953dbd0">magToFlux</a> (double mag)</td></tr>
<tr class="memdesc:aac406632e5ac15061216476af953dbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for converting magnitudes to fluxes.  <a href="#aac406632e5ac15061216476af953dbd0">More...</a><br/></td></tr>
<tr class="separator:aac406632e5ac15061216476af953dbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8adedfc70f7d0ecade52ac80bdaf03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a6d8adedfc70f7d0ecade52ac80bdaf03">fluxToMag</a> (const vector&lt; double &gt; &amp;fluxes, vector&lt; double &gt; &amp;mags)</td></tr>
<tr class="memdesc:a6d8adedfc70f7d0ecade52ac80bdaf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts fluxes to magnitudes.  <a href="#a6d8adedfc70f7d0ecade52ac80bdaf03">More...</a><br/></td></tr>
<tr class="separator:a6d8adedfc70f7d0ecade52ac80bdaf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac229e622fd0b58f75d3fcd5163417022"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#ac229e622fd0b58f75d3fcd5163417022">magToFlux</a> (const vector&lt; double &gt; &amp;mags, vector&lt; double &gt; &amp;fluxes)</td></tr>
<tr class="memdesc:ac229e622fd0b58f75d3fcd5163417022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts magnitudes to fluxes.  <a href="#ac229e622fd0b58f75d3fcd5163417022">More...</a><br/></td></tr>
<tr class="separator:ac229e622fd0b58f75d3fcd5163417022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb00d98b5c6eba69975ffaa5716db23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a3bb00d98b5c6eba69975ffaa5716db23">lessFinite</a> (double x, double y)</td></tr>
<tr class="memdesc:a3bb00d98b5c6eba69975ffaa5716db23"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacelcmc_1_1utils.html#a3bb00d98b5c6eba69975ffaa5716db23" title="lessFinite() allows floating-point numbers to be ordered consistently in the presence of NaNs...">lessFinite()</a> allows floating-point numbers to be ordered consistently in the presence of NaNs.  <a href="#a3bb00d98b5c6eba69975ffaa5716db23">More...</a><br/></td></tr>
<tr class="separator:a3bb00d98b5c6eba69975ffaa5716db23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6525d480b6719d87193b0df59eb870"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#adc6525d480b6719d87193b0df59eb870">removeNans</a> (const vector&lt; double &gt; &amp;badVals, vector&lt; double &gt; &amp;goodVals, const vector&lt; double &gt; &amp;sideVals, vector&lt; double &gt; &amp;matchVals)</td></tr>
<tr class="memdesc:adc6525d480b6719d87193b0df59eb870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes nans from a pair of vectors.  <a href="#adc6525d480b6719d87193b0df59eb870">More...</a><br/></td></tr>
<tr class="separator:adc6525d480b6719d87193b0df59eb870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fedc886faad874eac36d59533f79741"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a6fedc886faad874eac36d59533f79741">meanNoNan</a> (const vector&lt; double &gt; &amp;vals)</td></tr>
<tr class="memdesc:a6fedc886faad874eac36d59533f79741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the mean, ignoring NaNs.  <a href="#a6fedc886faad874eac36d59533f79741">More...</a><br/></td></tr>
<tr class="separator:a6fedc886faad874eac36d59533f79741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de785ad4a4cf869d836afd62dd8e193"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a1de785ad4a4cf869d836afd62dd8e193">varianceNoNan</a> (const vector&lt; double &gt; &amp;vals)</td></tr>
<tr class="memdesc:a1de785ad4a4cf869d836afd62dd8e193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the variance, ignoring NaNs.  <a href="#a1de785ad4a4cf869d836afd62dd8e193">More...</a><br/></td></tr>
<tr class="separator:a1de785ad4a4cf869d836afd62dd8e193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123408e42b765e943b0e3ce6cfc9c2d0"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; gsl_matrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a123408e42b765e943b0e3ce6cfc9c2d0">getHalfMatrix</a> (const shared_ptr&lt; gsl_matrix &gt; &amp;a)</td></tr>
<tr class="memdesc:a123408e42b765e943b0e3ce6cfc9c2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a matrix A, returns a matrix B with the property <img class="formulaInl" alt="$ A = B B^\intercal $" src="form_14.png"/>.  <a href="#a123408e42b765e943b0e3ce6cfc9c2d0">More...</a><br/></td></tr>
<tr class="separator:a123408e42b765e943b0e3ce6cfc9c2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a092d3308ced9057c0df4365d00a7fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a092d3308ced9057c0df4365d00a7fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a0a092d3308ced9057c0df4365d00a7fa">multiNormal</a> (const std::vector&lt; double &gt; &amp;indVec, const boost::shared_ptr&lt; gsl_matrix &gt; &amp;covar, std::vector&lt; double &gt; &amp;corrVec)</td></tr>
<tr class="memdesc:a0a092d3308ced9057c0df4365d00a7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms an uncorrelated sequence of Gaussian random numbers into a correlated sequence. <br/></td></tr>
<tr class="separator:a0a092d3308ced9057c0df4365d00a7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43709bc9d601425972f6abb4ecccef5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a43709bc9d601425972f6abb4ecccef5d">matrixCopy</a> (shared_ptr&lt; gsl_matrix &gt; &amp;target, const shared_ptr&lt; gsl_matrix &gt; &amp;newData)</td></tr>
<tr class="memdesc:a43709bc9d601425972f6abb4ecccef5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces one matrix with the value of another.  <a href="#a43709bc9d601425972f6abb4ecccef5d">More...</a><br/></td></tr>
<tr class="separator:a43709bc9d601425972f6abb4ecccef5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81b3ffaaef6e072dd808b72a41ef838"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#aa81b3ffaaef6e072dd808b72a41ef838">matrixEqual</a> (const gsl_matrix *const a, const gsl_matrix *const b)</td></tr>
<tr class="memdesc:aa81b3ffaaef6e072dd808b72a41ef838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether two matrices have approximately equal elements.  <a href="#aa81b3ffaaef6e072dd808b72a41ef838">More...</a><br/></td></tr>
<tr class="separator:aa81b3ffaaef6e072dd808b72a41ef838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5a7a1758f3b5df457f7a5251d1d9de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a4c5a7a1758f3b5df457f7a5251d1d9de">multiNormal</a> (const vector&lt; double &gt; &amp;indVec, const shared_ptr&lt; gsl_matrix &gt; &amp;covar, vector&lt; double &gt; &amp;corrVec)</td></tr>
<tr class="memdesc:a4c5a7a1758f3b5df457f7a5251d1d9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms an uncorrelated sequence of Gaussian random numbers into a correlated sequence.  <a href="#a4c5a7a1758f3b5df457f7a5251d1d9de">More...</a><br/></td></tr>
<tr class="separator:a4c5a7a1758f3b5df457f7a5251d1d9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace contains miscellaneous functions for handling generic problems. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a550c8ecef52e617df1124ecdf12bd4cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double lcmc::utils::fluxToMag </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>flux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for converting fluxes to magnitudes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flux</td><td>The flux to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding magnitude, assuming a flux of 1 unit corresponds to a magnitude of 0. Returns NaN if the flux is negative.</dd></dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>Does not throw exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d8adedfc70f7d0ecade52ac80bdaf03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::utils::fluxToMag </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>fluxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>mags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts fluxes to magnitudes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fluxes</td><td>A vector of fluxes to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mags</td><td>The corresponding magnitudes, assuming a flux of 1 unit corresponds to a magnitude of 0. Returns NaN wherever <code>flux</code> is negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>mags</code> may refer to the same vector as <code>fluxes</code> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>mags.size()</code> = <code>fluxes.size()</code> </dd>
<dd>
for all i in <code>mags</code>, <code>mags</code>[i] = <code>fluxToMag(fluxes[i])</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if there is not enough room to store the magnitudes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The arguments are unchanged in the event of an exception </dd></dl>

</div>
</div>
<a class="anchor" id="a123408e42b765e943b0e3ce6cfc9c2d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; gsl_matrix &gt; lcmc::utils::getHalfMatrix </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; gsl_matrix &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a matrix A, returns a matrix B with the property <img class="formulaInl" alt="$ A = B B^\intercal $" src="form_14.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The matrix to decompose</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer containing the newly allocated matrix B</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>a</code> is a square, symmetric, positive semi-definite matrix </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>return value is a newly allocated matrix with the property that multiplying it by its own transpose restores <code>a</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Returns different results on KPF-Hewlett4 and on cowling, particularly for matrices with lots of zero elements. The root cause is that a call to gsl_eigen_symmv() returns eigenvalues in a different order. Since the order of the eigenvalues is left undefined by the specification of gsl_eigen_symmv(), and since the output of <a class="el" href="namespacelcmc_1_1utils.html#a123408e42b765e943b0e3ce6cfc9c2d0" title="Given a matrix A, returns a matrix B with the property . ">getHalfMatrix()</a> passes all relevant statistical tests on both computers, its variant behavior is no longer considered a bug.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if there was not enough memory to compute the transformation </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown if the matrix is not square, symmetric, or positive semi-definite.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The parameters are unchanged in the event of an exception.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd>Find a faster implementation </dd></dl>

</div>
</div>
<a class="anchor" id="abe8f3c1ecc79bfa27e2e6057cc9f5a82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lcmc::utils::isMatrixClose </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_matrix *const&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether two matrices have approximately equal elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first matrix to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second matrix to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>The fractional tolerance to which <code>a[i,j]</code> and <code>b[i,j]</code> must match</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True iff <code>a</code> and <code>b</code> have the same dimensions, and each corresponding element is equal to within tolerance</dd></dl>
<dl class="section note"><dt>Note</dt><dd>if either <code>a</code> or <code>b</code> is a null pointer, returns false</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>tolerance</code> &gt; 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown if <code>tolerance</code> &le; 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The parameters are unchanged in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bb00d98b5c6eba69975ffaa5716db23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lcmc::utils::lessFinite </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacelcmc_1_1utils.html#a3bb00d98b5c6eba69975ffaa5716db23" title="lessFinite() allows floating-point numbers to be ordered consistently in the presence of NaNs...">lessFinite()</a> allows floating-point numbers to be ordered consistently in the presence of NaNs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>First value to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Second value to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If neither <code>x</code> nor <code>y</code> is NaN, returns (<code>x &lt; y</code>). Otherwise, assumes NaN is larger than any finite values, but less than positive infinity.</dd></dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>Does not throw exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="aac406632e5ac15061216476af953dbd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double lcmc::utils::magToFlux </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for converting magnitudes to fluxes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mag</td><td>The magnitude to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding flux, assuming a flux of 1 unit at 0th magnitude.</dd></dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>Does not throw exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="ac229e622fd0b58f75d3fcd5163417022"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::utils::magToFlux </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>mags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>fluxes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts magnitudes to fluxes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mags</td><td>A vector of magnitudes to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fluxes</td><td>The corresponding fluxes, assuming a flux of 1 unit at 0th magnitude.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>fluxes</code> may refer to the same vector as <code>mags</code> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>fluxes.size()</code> = <code>mags.size()</code> </dd>
<dd>
for all i in <code>mags</code>, <code>fluxes</code>[i] = <code>magToFlux(mags[i])</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if there is not enough room to store the fluxes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The arguments are unchanged in the event of an exception </dd></dl>

</div>
</div>
<a class="anchor" id="a43709bc9d601425972f6abb4ecccef5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::utils::matrixCopy </td>
          <td>(</td>
          <td class="paramtype">shared_ptr&lt; gsl_matrix &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; gsl_matrix &gt; &amp;&#160;</td>
          <td class="paramname"><em>newData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces one matrix with the value of another. </p>
<p>Unlike gsl_matrix_memcpy(), allows matrices to have different sizes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">target</td><td>The matrix pointer to be updated with a copy of newData </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newData</td><td>The data to copy to target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>target</code> points to a newly allocated matrix with the same dimensions and data as <code>newData</code> </dd>
<dd>
any data previously occupying <code>target</code> is cleaned up</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if the matrix could not be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The parameters are unchanged in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="aa81b3ffaaef6e072dd808b72a41ef838"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lcmc::utils::matrixEqual </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_matrix *const&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether two matrices have approximately equal elements. </p>
<p>This function is less efficient than gsl_is_matrix_equal(), but is provided for compatibility with older versions of the GSL</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first matrix to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second matrix to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True iff <code>a</code> and <code>b</code> have the same dimensions, and each corresponding element is equal.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>if either <code>a</code> or <code>b</code> is a null pointer, returns false</dd></dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>Does not throw exceptions </dd></dl>

</div>
</div>
<a class="anchor" id="a6fedc886faad874eac36d59533f79741"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double lcmc::utils::meanNoNan </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the mean, ignoring NaNs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vals</td><td>The values whose mean to take. May include NaNs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mean of the non-NaN elements of <code>vals</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">lcmc::stats::NotEnoughData</td><td>Thrown if all the elements of <code>vals</code> are NaNs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd><code>vals</code> is unchanged in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c5a7a1758f3b5df457f7a5251d1d9de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::utils::multiNormal </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>indVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; gsl_matrix &gt; &amp;&#160;</td>
          <td class="paramname"><em>covar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>corrVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms an uncorrelated sequence of Gaussian random numbers into a correlated sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indVec</td><td>A vector of independent unit Gaussian random numbers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">covar</td><td>The desired covariance matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">corrVec</td><td>A vector of correlated Gaussian random numbers with mean zero and covariance matrix covar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>indVec.size()</code> = <code>covar-&gt;size1</code> = <code>covar-&gt;size2</code> </dd>
<dd>
<code>covar</code> is symmetric and positive semidefinite </dd>
<dd>
<code>corrVec</code> may refer to the same vector as <code>indVec</code> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>corrVec.size()</code> = <code>indVec.size()</code> </dd></dl>
<dl class="section user"><dt>Performance</dt><dd>O(N<sup>3</sup>) time, where N = <code>times.size()</code> </dd></dl>
<dl class="section user"><dt></dt><dd>O(N<sup>2</sup>) memory</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if there was not enough memory to compute the transformation </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown if the lengths do not match or if the matrix is not symmetric or positive semidefinite.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The parameters are unchanged in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="adc6525d480b6719d87193b0df59eb870"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::utils::removeNans </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>badVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>goodVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sideVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>matchVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes nans from a pair of vectors. </p>
<p>Removes NaNs from a pair of vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">badVals</td><td>A vector of values that may contain NaNs. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">goodVals</td><td>A vector containing all elements in <code>badVals</code> that are not NaNs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sideVals</td><td>A vector of other measurements that correspond to the values in <code>badVals</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matchVals</td><td>A vector containing those elements in <code>sideVals</code> whose counterparts in <code>badVals</code> are not NaNs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>badVals.size()</code> = <code>sideVals.size()</code> </dd>
<dd>
<code>goodVals</code>, <code>badVals</code>, <code>sideVals</code>, and <code>matchVals</code> are all distinct objects</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>goodVals.size()</code> = <code>matchVals.size()</code> </dd>
<dd>
<code>goodVals.size()</code> &le; <code>badVals.size()</code> </dd>
<dd>
<code>sideVals.size()</code> &le; <code>matchVals.size()</code> </dd>
<dd>
The elements in <code>goodVals</code> are in the same order as in <code>badVals</code> </dd>
<dd>
The elements in <code>matchVals</code> are in the same order as in <code>sideVals</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown if <code>badVals.size()</code> &ne; <code>sideVals.size()</code> </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if could not allocate <code>sideVals</code> or <code>matchVals</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>None of the arguments are changed in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a1de785ad4a4cf869d836afd62dd8e193"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double lcmc::utils::varianceNoNan </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the variance, ignoring NaNs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vals</td><td>The values whose variance to take. May include NaNs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The variance of the non-NaN elements of <code>vals</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">lcmc::stats::NotEnoughData</td><td>Thrown if all or all but one of the elements of <code>vals</code> are NaNs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd><code>vals</code> is unchanged in the event of an exception. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelcmc.html">lcmc</a></li><li class="navelem"><a class="el" href="namespacelcmc_1_1utils.html">utils</a></li>
    <li class="footer">Generated on Mon Aug 18 2014 19:22:01 for Lightcurve MC by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>

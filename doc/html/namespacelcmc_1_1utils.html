<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Lightcurve MC: lcmc::utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Lightcurve MC
   &#160;<span id="projectnumber">2.1.0-devel</span>
   </div>
   <div id="projectbrief">Lightcurve MC carries out Monte Carlo simulations of statistical light curve analyses.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacelcmc_1_1utils.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lcmc::utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This namespace contains miscellaneous functions for handling generic problems.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a550c8ecef52e617df1124ecdf12bd4cd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a550c8ecef52e617df1124ecdf12bd4cd">fluxToMag</a> (double flux)</td></tr>
<tr class="memdesc:a550c8ecef52e617df1124ecdf12bd4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for converting fluxes to magnitudes.  <a href="#a550c8ecef52e617df1124ecdf12bd4cd">More...</a><br/></td></tr>
<tr class="separator:a550c8ecef52e617df1124ecdf12bd4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8adedfc70f7d0ecade52ac80bdaf03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a6d8adedfc70f7d0ecade52ac80bdaf03">fluxToMag</a> (const vector&lt; double &gt; &amp;fluxes, vector&lt; double &gt; &amp;mags)</td></tr>
<tr class="memdesc:a6d8adedfc70f7d0ecade52ac80bdaf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts fluxes to magnitudes.  <a href="#a6d8adedfc70f7d0ecade52ac80bdaf03">More...</a><br/></td></tr>
<tr class="separator:a6d8adedfc70f7d0ecade52ac80bdaf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc8bf83f3aad761a64bf929e0701212"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#afdc8bf83f3aad761a64bf929e0701212">getHalfMatrix</a> (const gsl_matrix *const a, gsl_matrix *&amp;b)</td></tr>
<tr class="memdesc:afdc8bf83f3aad761a64bf929e0701212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a matrix A, returns a matrix B with the property A = B * transpose(B)  <a href="#afdc8bf83f3aad761a64bf929e0701212">More...</a><br/></td></tr>
<tr class="separator:afdc8bf83f3aad761a64bf929e0701212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8f3c1ecc79bfa27e2e6057cc9f5a82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#abe8f3c1ecc79bfa27e2e6057cc9f5a82">isMatrixClose</a> (const gsl_matrix *const a, const gsl_matrix *const b, double tolerance)</td></tr>
<tr class="memdesc:abe8f3c1ecc79bfa27e2e6057cc9f5a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether two matrices have approximately equal elements.  <a href="#abe8f3c1ecc79bfa27e2e6057cc9f5a82">More...</a><br/></td></tr>
<tr class="separator:abe8f3c1ecc79bfa27e2e6057cc9f5a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e75394f3ac515b4bdabac4cd22b9e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a23e75394f3ac515b4bdabac4cd22b9e3">isNan</a> (double x)</td></tr>
<tr class="memdesc:a23e75394f3ac515b4bdabac4cd22b9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">isNan tests whether a floating-point number is undefined  <a href="#a23e75394f3ac515b4bdabac4cd22b9e3">More...</a><br/></td></tr>
<tr class="separator:a23e75394f3ac515b4bdabac4cd22b9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad050e946f0169e5214819a7aefd88bef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#ad050e946f0169e5214819a7aefd88bef">isNanOrInf</a> (double x)</td></tr>
<tr class="memdesc:ad050e946f0169e5214819a7aefd88bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">isNanOrInf tests whether a floating-point number is non-finite  <a href="#ad050e946f0169e5214819a7aefd88bef">More...</a><br/></td></tr>
<tr class="separator:ad050e946f0169e5214819a7aefd88bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb00d98b5c6eba69975ffaa5716db23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a3bb00d98b5c6eba69975ffaa5716db23">lessFinite</a> (double x, double y)</td></tr>
<tr class="memdesc:a3bb00d98b5c6eba69975ffaa5716db23"><td class="mdescLeft">&#160;</td><td class="mdescRight">lessFinite allows floating-point numbers to be compared safely in the presence of NaNs.  <a href="#a3bb00d98b5c6eba69975ffaa5716db23">More...</a><br/></td></tr>
<tr class="separator:a3bb00d98b5c6eba69975ffaa5716db23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac406632e5ac15061216476af953dbd0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#aac406632e5ac15061216476af953dbd0">magToFlux</a> (double mag)</td></tr>
<tr class="memdesc:aac406632e5ac15061216476af953dbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for converting magnitudes to fluxes.  <a href="#aac406632e5ac15061216476af953dbd0">More...</a><br/></td></tr>
<tr class="separator:aac406632e5ac15061216476af953dbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac229e622fd0b58f75d3fcd5163417022"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#ac229e622fd0b58f75d3fcd5163417022">magToFlux</a> (const vector&lt; double &gt; &amp;mags, vector&lt; double &gt; &amp;fluxes)</td></tr>
<tr class="memdesc:ac229e622fd0b58f75d3fcd5163417022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts magnitudes to fluxes.  <a href="#ac229e622fd0b58f75d3fcd5163417022">More...</a><br/></td></tr>
<tr class="separator:ac229e622fd0b58f75d3fcd5163417022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fedc886faad874eac36d59533f79741"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a6fedc886faad874eac36d59533f79741">meanNoNan</a> (const vector&lt; double &gt; &amp;vals)</td></tr>
<tr class="memdesc:a6fedc886faad874eac36d59533f79741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the mean, ignoring NaNs.  <a href="#a6fedc886faad874eac36d59533f79741">More...</a><br/></td></tr>
<tr class="separator:a6fedc886faad874eac36d59533f79741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a011fed98f692ed2080dcdaca567635"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a5a011fed98f692ed2080dcdaca567635">multiNormal</a> (const std::vector&lt; double &gt; &amp;indVec, const gsl_matrix &amp;covar, std::vector&lt; double &gt; &amp;corrVec)</td></tr>
<tr class="memdesc:a5a011fed98f692ed2080dcdaca567635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms an uncorrelated sequence of Gaussian random numbers into a correlated sequence.  <a href="#a5a011fed98f692ed2080dcdaca567635">More...</a><br/></td></tr>
<tr class="separator:a5a011fed98f692ed2080dcdaca567635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6525d480b6719d87193b0df59eb870"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#adc6525d480b6719d87193b0df59eb870">removeNans</a> (const vector&lt; double &gt; &amp;badVals, vector&lt; double &gt; &amp;goodVals, const vector&lt; double &gt; &amp;sideVals, vector&lt; double &gt; &amp;matchVals)</td></tr>
<tr class="memdesc:adc6525d480b6719d87193b0df59eb870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes nans from a pair of vectors.  <a href="#adc6525d480b6719d87193b0df59eb870">More...</a><br/></td></tr>
<tr class="separator:adc6525d480b6719d87193b0df59eb870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7d70297477d3dcd24b7ee0679cca11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a0b7d70297477d3dcd24b7ee0679cca11">removeNans</a> (const DoubleVec &amp;badVals, DoubleVec &amp;goodVals, const DoubleVec &amp;sideVals, DoubleVec &amp;matchVals)</td></tr>
<tr class="memdesc:a0b7d70297477d3dcd24b7ee0679cca11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes nans from a pair of vectors.  <a href="#a0b7d70297477d3dcd24b7ee0679cca11">More...</a><br/></td></tr>
<tr class="separator:a0b7d70297477d3dcd24b7ee0679cca11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc50e75dbecd86fd049aba58a1dad73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a8bc50e75dbecd86fd049aba58a1dad73">replaceMatrix</a> (gsl_matrix *&amp;target, const gsl_matrix *const newData)</td></tr>
<tr class="memdesc:a8bc50e75dbecd86fd049aba58a1dad73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces one matrix with another.  <a href="#a8bc50e75dbecd86fd049aba58a1dad73">More...</a><br/></td></tr>
<tr class="separator:a8bc50e75dbecd86fd049aba58a1dad73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de785ad4a4cf869d836afd62dd8e193"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1utils.html#a1de785ad4a4cf869d836afd62dd8e193">varianceNoNan</a> (const vector&lt; double &gt; &amp;vals)</td></tr>
<tr class="memdesc:a1de785ad4a4cf869d836afd62dd8e193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the variance, ignoring NaNs.  <a href="#a1de785ad4a4cf869d836afd62dd8e193">More...</a><br/></td></tr>
<tr class="separator:a1de785ad4a4cf869d836afd62dd8e193"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace contains miscellaneous functions for handling generic problems. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a550c8ecef52e617df1124ecdf12bd4cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double lcmc::utils::fluxToMag </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>flux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for converting fluxes to magnitudes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flux</td><td>The flux to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding magnitude, assuming a flux of 1 unit corresponds to a magnitude of 0. Returns NaN if the flux is negative.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Desired behavior for negative fluxes? </dd></dl>

</div>
</div>
<a class="anchor" id="a6d8adedfc70f7d0ecade52ac80bdaf03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::utils::fluxToMag </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>fluxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>mags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts fluxes to magnitudes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fluxes</td><td>A vector of fluxes to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mags</td><td>The corresponding magnitudes, assuming a flux of 1 unit corresponds to a magnitude of 0. Returns NaN wherever flux is negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>mags.size() == fluxes.size() </dd></dl>

</div>
</div>
<a class="anchor" id="afdc8bf83f3aad761a64bf929e0701212"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::utils::getHalfMatrix </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a matrix A, returns a matrix B with the property A = B * transpose(B) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The matrix to decompose </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>A pointer to which the result matrix B is assigned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>a is a square, symmetric, positive semi-definite matrix </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>b points to a newly allocated matrix with the property that multiplying it by its own transpose restores A </dd>
<dd>
any data previously pointed to by b is deleted</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000044">Todo:</a></b></dt><dd>Benchmark which of several possible implementations is faster</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Returns different results on KPF-Hewlett4 and on cowling, particularly for matrices a with lots of zero elements. The root cause is that a call to gsl_eigen_symmv() returns eigenvalues in a different order. Since the order of the eigenvalues is left undefined by the specification of gsl_eigen_symmv(), and since the output of <a class="el" href="namespacelcmc_1_1utils.html#afdc8bf83f3aad761a64bf929e0701212" title="Given a matrix A, returns a matrix B with the property A = B * transpose(B)">getHalfMatrix()</a> passes all relevant statistical tests on both computers, its variant behavior is no longer considered a bug. </dd></dl>

</div>
</div>
<a class="anchor" id="abe8f3c1ecc79bfa27e2e6057cc9f5a82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lcmc::utils::isMatrixClose </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *const&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_matrix *const&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether two matrices have approximately equal elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first matrix to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second matrix to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>The fractional tolerance to which a[i,j] and b[i,j] must match</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True iff a and b have the same dimensions, and each corresponding element is equal to within tolerance</dd></dl>
<dl class="section note"><dt>Note</dt><dd>if either a or b is a null pointer, returns false </dd></dl>

</div>
</div>
<a class="anchor" id="a23e75394f3ac515b4bdabac4cd22b9e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lcmc::utils::isNan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>isNan tests whether a floating-point number is undefined </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The number to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if x equals signaling or quiet not-a-number </dd></dl>

</div>
</div>
<a class="anchor" id="ad050e946f0169e5214819a7aefd88bef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lcmc::utils::isNanOrInf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>isNanOrInf tests whether a floating-point number is non-finite </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The number to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if x equals signaling or quiet not-a-number, or x is infinite </dd></dl>

</div>
</div>
<a class="anchor" id="a3bb00d98b5c6eba69975ffaa5716db23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lcmc::utils::lessFinite </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>lessFinite allows floating-point numbers to be compared safely in the presence of NaNs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>First value to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Second value to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If neither x nor y is NaN, returns (x &lt; y). Otherwise, assumes NaN is larger than any finite values, but less than positive infinity. </dd></dl>

</div>
</div>
<a class="anchor" id="aac406632e5ac15061216476af953dbd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double lcmc::utils::magToFlux </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for converting magnitudes to fluxes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mag</td><td>The magnitude to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding flux, assuming a flux of 1 unit at 0th magnitude. </dd></dl>

</div>
</div>
<a class="anchor" id="ac229e622fd0b58f75d3fcd5163417022"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::utils::magToFlux </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>mags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>fluxes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts magnitudes to fluxes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mags</td><td>A vector of magnitudes to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fluxes</td><td>The corresponding fluxes, assuming a flux of 1 unit at 0th magnitude.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>fluxes.size() == mags.size() </dd></dl>

</div>
</div>
<a class="anchor" id="a6fedc886faad874eac36d59533f79741"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double lcmc::utils::meanNoNan </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the mean, ignoring NaNs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vals</td><td>The values of which to take the mean. May include NaNs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mean of the non-NaN elements of vals. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a011fed98f692ed2080dcdaca567635"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::utils::multiNormal </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>indVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_matrix &amp;&#160;</td>
          <td class="paramname"><em>covar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>corrVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms an uncorrelated sequence of Gaussian random numbers into a correlated sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indVec</td><td>A vector of independent unit Gaussian random numbers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">covar</td><td>The desired covariance matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">corrVec</td><td>A vector of correlated Gaussian random numbers with mean zero and covariance matrix covar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>indVec.size() == covar.size1 == covar.size2 </dd>
<dd>
corrVec may refer to the same vector as indVec</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>corrVec.size() == indVec.size()</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000045">Todo:</a></b></dt><dd>Add input validation </dd></dl>

</div>
</div>
<a class="anchor" id="adc6525d480b6719d87193b0df59eb870"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::utils::removeNans </td>
          <td>(</td>
          <td class="paramtype">const DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>badVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>goodVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>sideVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>matchVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes nans from a pair of vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">badVals</td><td>A vector of values that may contain NaNs. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">goodVals</td><td>A vector containing all elements in badVals that are not NaNs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sideVals</td><td>A vector of other measurements that correspond to the values in badVals. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matchVals</td><td>A vector containing those elements in sideVals whose counterparts in badVals are not NaNs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>badVals.size() == sideVals.size() </dd>
<dd>
goodVals, badVals, sideVals, and matchVals are all distinct objects</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>goodVals.size() == matchVals.size()</dd>
<dd>
goodVals.size() &lt;= badVals.size() </dd>
<dd>
sideVals.size() &lt;= matchVals.size()</dd>
<dd>
The elements in goodVals are in the same order as in badVals </dd>
<dd>
The elements in matchVals are in the same order as in sideVals </dd></dl>

</div>
</div>
<a class="anchor" id="a0b7d70297477d3dcd24b7ee0679cca11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::utils::removeNans </td>
          <td>(</td>
          <td class="paramtype">const DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>badVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>goodVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>sideVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>matchVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes nans from a pair of vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">badVals</td><td>A vector of values that may contain NaNs. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">goodVals</td><td>A vector containing all elements in badVals that are not NaNs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sideVals</td><td>A vector of other measurements that correspond to the values in badVals. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matchVals</td><td>A vector containing those elements in sideVals whose counterparts in badVals are not NaNs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>badVals.size() == sideVals.size() </dd>
<dd>
goodVals, badVals, sideVals, and matchVals are all distinct objects</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>goodVals.size() == matchVals.size()</dd>
<dd>
goodVals.size() &lt;= badVals.size() </dd>
<dd>
sideVals.size() &lt;= matchVals.size()</dd>
<dd>
The elements in goodVals are in the same order as in badVals </dd>
<dd>
The elements in matchVals are in the same order as in sideVals </dd></dl>

</div>
</div>
<a class="anchor" id="a8bc50e75dbecd86fd049aba58a1dad73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::utils::replaceMatrix </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_matrix *const&#160;</td>
          <td class="paramname"><em>newData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces one matrix with another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">target</td><td>The matrix pointer to be updated with a copy of newData </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newData</td><td>The data to copy to target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>target points to a newly allocated matrix with the same dimensions and data as newData </dd>
<dd>
any data previously occupying target is cleaned up </dd></dl>

</div>
</div>
<a class="anchor" id="a1de785ad4a4cf869d836afd62dd8e193"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double lcmc::utils::varianceNoNan </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the variance, ignoring NaNs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vals</td><td>The values of which to take the variance. May include NaNs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The variance of the non-NaN elements of vals. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelcmc.html">lcmc</a></li><li class="navelem"><a class="el" href="namespacelcmc_1_1utils.html">utils</a></li>
    <li class="footer">Generated on Fri Apr 26 2013 22:19:24 for Lightcurve MC by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>

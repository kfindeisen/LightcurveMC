<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Lightcurve MC: lcmc::stats Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Lightcurve MC
   &#160;<span id="projectnumber">2.3.0</span>
   </div>
   <div id="projectbrief">Lightcurve MC carries out Monte Carlo simulations of statistical light curve analysis.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacelcmc_1_1stats.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lcmc::stats Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This namespace identifies data types and functions that handle data analysis on simulated light curves.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacelcmc_1_1stats_1_1interp"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats_1_1interp.html">interp</a></td></tr>
<tr class="memdesc:namespacelcmc_1_1stats_1_1interp"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespacelcmc_1_1stats_1_1interp.html">interp</a> namespace is intended to allow other ACF algorithms to be swapped with a simple <code>using</code> declaration. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcmc_1_1stats_1_1_lc_bin_stats.html">LcBinStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Organizes test statistics on artificial light curves.  <a href="classlcmc_1_1stats_1_1_lc_bin_stats.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcmc_1_1stats_1_1_more_than.html">MoreThan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary predicate for whether a value is more than some threshold.  <a href="classlcmc_1_1stats_1_1_more_than.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcmc_1_1stats_1_1_less_than.html">LessThan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary predicate for whether a value is less than some threshold.  <a href="classlcmc_1_1stats_1_1_less_than.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcmc_1_1stats_1_1_i_stats.html">IStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common interface for compilations of statistics.  <a href="classlcmc_1_1stats_1_1_i_stats.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcmc_1_1stats_1_1_named_collection.html">NamedCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class defining infrastructure used by statistic collections.  <a href="classlcmc_1_1stats_1_1_named_collection.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcmc_1_1stats_1_1_collected_scalars.html">CollectedScalars</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a collection of scalar statistics.  <a href="classlcmc_1_1stats_1_1_collected_scalars.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcmc_1_1stats_1_1_collected_vectors.html">CollectedVectors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a collection of vector statistics.  <a href="classlcmc_1_1stats_1_1_collected_vectors.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcmc_1_1stats_1_1_collected_pairs.html">CollectedPairs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a collection of statistics where each statistic represents the sampling of a function, <img class="formulaInl" alt="$\{(x_i, y_i)\}$" src="form_6.png"/>.  <a href="classlcmc_1_1stats_1_1_collected_pairs.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a52dbeaa8c5a81665a3c1f1423cd02ede"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52dbeaa8c5a81665a3c1f1423cd02ede"></a>
typedef std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a52dbeaa8c5a81665a3c1f1423cd02ede">DoubleVec</a></td></tr>
<tr class="memdesc:a52dbeaa8c5a81665a3c1f1423cd02ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for a vector of doubles. <br/></td></tr>
<tr class="separator:a52dbeaa8c5a81665a3c1f1423cd02ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619f03446471119c2cb3bf4fa5ca1b4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a619f03446471119c2cb3bf4fa5ca1b4a"></a>
typedef std::map&lt; string, <br class="typebreak"/>
const <a class="el" href="namespacelcmc_1_1stats.html#a4b5a1f3a60aa397d707b7d221d6a034c">StatType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a619f03446471119c2cb3bf4fa5ca1b4a">StatRegistry</a></td></tr>
<tr class="memdesc:a619f03446471119c2cb3bf4fa5ca1b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type for streamlining the implementation of functions that construct or select statistics. <br/></td></tr>
<tr class="separator:a619f03446471119c2cb3bf4fa5ca1b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30afdb139fceb9b56dcffbd4b94bdcaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30afdb139fceb9b56dcffbd4b94bdcaa"></a>
typedef std::pair&lt; string, <br class="typebreak"/>
const <a class="el" href="namespacelcmc_1_1stats.html#a4b5a1f3a60aa397d707b7d221d6a034c">StatType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a30afdb139fceb9b56dcffbd4b94bdcaa">StatEntry</a></td></tr>
<tr class="memdesc:a30afdb139fceb9b56dcffbd4b94bdcaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type for streamlining the implementation of functions that construct or select statistics. <br/></td></tr>
<tr class="separator:a30afdb139fceb9b56dcffbd4b94bdcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4b5a1f3a60aa397d707b7d221d6a034c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a4b5a1f3a60aa397d707b7d221d6a034c">StatType</a> { <br/>
&#160;&#160;<a class="el" href="namespacelcmc_1_1stats.html#a4b5a1f3a60aa397d707b7d221d6a034ca287262010e6e0b29d1e91f134e817cd6">C1</a>, 
<a class="el" href="namespacelcmc_1_1stats.html#a4b5a1f3a60aa397d707b7d221d6a034ca16e2c7713481c044411250289e9be9fa">PERIOD</a>, 
<a class="el" href="namespacelcmc_1_1stats.html#a4b5a1f3a60aa397d707b7d221d6a034cac013b980d88d361ce0b6a3bd3517e795">PERIODOGRAM</a>, 
<a class="el" href="namespacelcmc_1_1stats.html#a4b5a1f3a60aa397d707b7d221d6a034ca1cbc544d527b683464b6c4d27ed86e9d">DMDTCUT</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacelcmc_1_1stats.html#a4b5a1f3a60aa397d707b7d221d6a034caab045169d278e7b6b2935ebb829d6974">DMDT</a>, 
<a class="el" href="namespacelcmc_1_1stats.html#a4b5a1f3a60aa397d707b7d221d6a034ca95ed1d3e7d7405c1c9d597798f2b4b21">IACFCUT</a>, 
<a class="el" href="namespacelcmc_1_1stats.html#a4b5a1f3a60aa397d707b7d221d6a034ca65cdfafd12856d87cd063c2f5f78d041">IACF</a>, 
<a class="el" href="namespacelcmc_1_1stats.html#a4b5a1f3a60aa397d707b7d221d6a034ca9eee78f67dee89b19c2423037124d2cd">SACFCUT</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacelcmc_1_1stats.html#a4b5a1f3a60aa397d707b7d221d6a034ca3dcb41e35d1599d6bb602a7992b91cfe">SACF</a>, 
<a class="el" href="namespacelcmc_1_1stats.html#a4b5a1f3a60aa397d707b7d221d6a034cac8c6d4e7d3dee8feba327d72103bed3c">PEAKCUT</a>, 
<a class="el" href="namespacelcmc_1_1stats.html#a4b5a1f3a60aa397d707b7d221d6a034caaf3d1af1bd8b5d95d66473e62941c324">PEAKFIND</a>, 
<a class="el" href="namespacelcmc_1_1stats.html#a4b5a1f3a60aa397d707b7d221d6a034cad85ca508a0d9f802af261d70c7f1d914">GPTAU</a>
<br/>
 }</td></tr>
<tr class="memdesc:a4b5a1f3a60aa397d707b7d221d6a034c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to tell the program which statistics to calculate.  <a href="namespacelcmc_1_1stats.html#a4b5a1f3a60aa397d707b7d221d6a034c">More...</a><br/></td></tr>
<tr class="separator:a4b5a1f3a60aa397d707b7d221d6a034c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a74738a268310228387125a0d85bac3d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a74738a268310228387125a0d85bac3d5">scargleAdapter</a> (const <a class="el" href="namespacelcmc_1_1stats.html#a52dbeaa8c5a81665a3c1f1423cd02ede">DoubleVec</a> &amp;times, const <a class="el" href="namespacelcmc_1_1stats.html#a52dbeaa8c5a81665a3c1f1423cd02ede">DoubleVec</a> &amp;data, double offStep, size_t nOffsets, <a class="el" href="namespacelcmc_1_1stats.html#a52dbeaa8c5a81665a3c1f1423cd02ede">DoubleVec</a> &amp;acfs)</td></tr>
<tr class="memdesc:a74738a268310228387125a0d85bac3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for calculating the Scargle ACF.  <a href="#a74738a268310228387125a0d85bac3d5">More...</a><br/></td></tr>
<tr class="separator:a74738a268310228387125a0d85bac3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfd65ff4f2d027c2db83ceae91760d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a8dfd65ff4f2d027c2db83ceae91760d1">squareAmpHalfComplex</a> (double hcArr[], size_t n)</td></tr>
<tr class="memdesc:a8dfd65ff4f2d027c2db83ceae91760d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the squared amplitude of a half-complex vector.  <a href="#a8dfd65ff4f2d027c2db83ceae91760d1">More...</a><br/></td></tr>
<tr class="separator:a8dfd65ff4f2d027c2db83ceae91760d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c79dcd216675ddde83c6593b67163e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a60c79dcd216675ddde83c6593b67163e">autoCorrelation_sp</a> (const double data[], double acfs[], size_t n)</td></tr>
<tr class="memdesc:a60c79dcd216675ddde83c6593b67163e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the lag-<code>n</code> autocorrelation of the dataset <code>data</code>, using the signal-processing convention.  <a href="#a60c79dcd216675ddde83c6593b67163e">More...</a><br/></td></tr>
<tr class="separator:a60c79dcd216675ddde83c6593b67163e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc58172e2cb4a86a72d78b2e17bc69bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#afc58172e2cb4a86a72d78b2e17bc69bd">autoCorrelation_stat</a> (const double data[], double acfs[], size_t n)</td></tr>
<tr class="memdesc:afc58172e2cb4a86a72d78b2e17bc69bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the lag-<code>n</code> autocorrelation of the dataset <code>data</code>, using the statistical analysis convention.  <a href="#afc58172e2cb4a86a72d78b2e17bc69bd">More...</a><br/></td></tr>
<tr class="separator:afc58172e2cb4a86a72d78b2e17bc69bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6861bfef2e6748dffcc03f7bc3f6885c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a6861bfef2e6748dffcc03f7bc3f6885c">doAcf</a> (const vector&lt; double &gt; &amp;times, const vector&lt; double &gt; &amp;data, void(*acfFunc)(const vector&lt; double &gt; &amp;, const vector&lt; double &gt; &amp;, double, size_t, vector&lt; double &gt; &amp;), bool getCut, bool getPlot, <a class="el" href="classlcmc_1_1stats_1_1_collected_scalars.html">CollectedScalars</a> &amp;cut9, <a class="el" href="classlcmc_1_1stats_1_1_collected_scalars.html">CollectedScalars</a> &amp;cut4, <a class="el" href="classlcmc_1_1stats_1_1_collected_scalars.html">CollectedScalars</a> &amp;cut2, <a class="el" href="classlcmc_1_1stats_1_1_collected_pairs.html">CollectedPairs</a> &amp;acfPlot)</td></tr>
<tr class="memdesc:a6861bfef2e6748dffcc03f7bc3f6885c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does all ACF-related computations for a given light curve.  <a href="#a6861bfef2e6748dffcc03f7bc3f6885c">More...</a><br/></td></tr>
<tr class="separator:a6861bfef2e6748dffcc03f7bc3f6885c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f582da5d0dfcbf71bb31bd1c63d805"><td class="memTemplParams" colspan="2">template&lt;class UnaryPredicate &gt; </td></tr>
<tr class="memitem:ae0f582da5d0dfcbf71bb31bd1c63d805"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#ae0f582da5d0dfcbf71bb31bd1c63d805">cutFunction</a> (const vector&lt; double &gt; &amp;pos, const vector&lt; double &gt; &amp;func, UnaryPredicate pred)</td></tr>
<tr class="memdesc:ae0f582da5d0dfcbf71bb31bd1c63d805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first location on a grid where a predicate is true.  <a href="#ae0f582da5d0dfcbf71bb31bd1c63d805">More...</a><br/></td></tr>
<tr class="separator:ae0f582da5d0dfcbf71bb31bd1c63d805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7797cbec7ef870b86f9850d9a296b8d8"><td class="memTemplParams" colspan="2">template&lt;class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a7797cbec7ef870b86f9850d9a296b8d8"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a7797cbec7ef870b86f9850d9a296b8d8">cutFunctionReverse</a> (const vector&lt; double &gt; &amp;pos, const vector&lt; double &gt; &amp;func, UnaryPredicate pred)</td></tr>
<tr class="memdesc:a7797cbec7ef870b86f9850d9a296b8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last location on a grid where a predicate is true.  <a href="#a7797cbec7ef870b86f9850d9a296b8d8">More...</a><br/></td></tr>
<tr class="separator:a7797cbec7ef870b86f9850d9a296b8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbe18e1119d82ef1e25de1c9993e0fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#abcbe18e1119d82ef1e25de1c9993e0fd">doDmdt</a> (const vector&lt; double &gt; &amp;times, const vector&lt; double &gt; &amp;mags, bool getCut, bool getPlot, <a class="el" href="classlcmc_1_1stats_1_1_collected_scalars.html">CollectedScalars</a> &amp;cut50Amp3, <a class="el" href="classlcmc_1_1stats_1_1_collected_scalars.html">CollectedScalars</a> &amp;cut50Amp2, <a class="el" href="classlcmc_1_1stats_1_1_collected_scalars.html">CollectedScalars</a> &amp;cut90Amp3, <a class="el" href="classlcmc_1_1stats_1_1_collected_scalars.html">CollectedScalars</a> &amp;cut90Amp2, <a class="el" href="classlcmc_1_1stats_1_1_collected_pairs.html">CollectedPairs</a> &amp;dmdtMed)</td></tr>
<tr class="memdesc:abcbe18e1119d82ef1e25de1c9993e0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does all &Delta;m&Delta;t-related computations for a given light curve.  <a href="#abcbe18e1119d82ef1e25de1c9993e0fd">More...</a><br/></td></tr>
<tr class="separator:abcbe18e1119d82ef1e25de1c9993e0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bce18a560b85763c1d68b4751ba1106"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a9bce18a560b85763c1d68b4751ba1106">rmsVsTRooted</a> (const <a class="el" href="namespacelcmc_1_1stats.html#a52dbeaa8c5a81665a3c1f1423cd02ede">DoubleVec</a> &amp;times, const <a class="el" href="namespacelcmc_1_1stats.html#a52dbeaa8c5a81665a3c1f1423cd02ede">DoubleVec</a> &amp;fluxes, <a class="el" href="namespacelcmc_1_1stats.html#a52dbeaa8c5a81665a3c1f1423cd02ede">DoubleVec</a> &amp;timeSteps, <a class="el" href="namespacelcmc_1_1stats.html#a52dbeaa8c5a81665a3c1f1423cd02ede">DoubleVec</a> &amp;rmsValues)</td></tr>
<tr class="memdesc:a9bce18a560b85763c1d68b4751ba1106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the RMS binned over ever-larger subintervals of the data.  <a href="#a9bce18a560b85763c1d68b4751ba1106">More...</a><br/></td></tr>
<tr class="separator:a9bce18a560b85763c1d68b4751ba1106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352e5fc1c24fefa5c94a4ff7b7058344"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a352e5fc1c24fefa5c94a4ff7b7058344">rmsVsTAllPairs</a> (const <a class="el" href="namespacelcmc_1_1stats.html#a52dbeaa8c5a81665a3c1f1423cd02ede">DoubleVec</a> &amp;times, const <a class="el" href="namespacelcmc_1_1stats.html#a52dbeaa8c5a81665a3c1f1423cd02ede">DoubleVec</a> &amp;fluxes, <a class="el" href="namespacelcmc_1_1stats.html#a52dbeaa8c5a81665a3c1f1423cd02ede">DoubleVec</a> &amp;timeSteps, <a class="el" href="namespacelcmc_1_1stats.html#a52dbeaa8c5a81665a3c1f1423cd02ede">DoubleVec</a> &amp;rmsValues)</td></tr>
<tr class="memdesc:a352e5fc1c24fefa5c94a4ff7b7058344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the RMS binned over ever-larger subintervals of the data.  <a href="#a352e5fc1c24fefa5c94a4ff7b7058344">More...</a><br/></td></tr>
<tr class="separator:a352e5fc1c24fefa5c94a4ff7b7058344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697c54a73393b6f104833494cb7a5a45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a697c54a73393b6f104833494cb7a5a45">fitGaussGp</a> (const vector&lt; double &gt; &amp;times, const vector&lt; double &gt; &amp;data, double &amp;timescale, double &amp;timeError)</td></tr>
<tr class="memdesc:a697c54a73393b6f104833494cb7a5a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the best fit solution to a squared exponential Gaussian process model.  <a href="#a697c54a73393b6f104833494cb7a5a45">More...</a><br/></td></tr>
<tr class="separator:a697c54a73393b6f104833494cb7a5a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f720937490ca2df81c56324f924bbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a15f720937490ca2df81c56324f924bbb">doGaussFit</a> (const vector&lt; double &gt; &amp;times, const vector&lt; double &gt; &amp;data, bool getGp, double trueTime, <a class="el" href="classlcmc_1_1stats_1_1_collected_scalars.html">CollectedScalars</a> &amp;timescales, <a class="el" href="classlcmc_1_1stats_1_1_collected_scalars.html">CollectedScalars</a> &amp;timeErrors, <a class="el" href="classlcmc_1_1stats_1_1_collected_scalars.html">CollectedScalars</a> &amp;normDevs)</td></tr>
<tr class="memdesc:a15f720937490ca2df81c56324f924bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does all GP-related computations for a given light curve.  <a href="#a15f720937490ca2df81c56324f924bbb">More...</a><br/></td></tr>
<tr class="separator:a15f720937490ca2df81c56324f924bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae875834549b5401b827d6783cd4173bf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#ae875834549b5401b827d6783cd4173bf">getC1</a> (const <a class="el" href="namespacelcmc_1_1stats.html#a52dbeaa8c5a81665a3c1f1423cd02ede">DoubleVec</a> &amp;mags)</td></tr>
<tr class="memdesc:ae875834549b5401b827d6783cd4173bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the modified C1 statistic.  <a href="#ae875834549b5401b827d6783cd4173bf">More...</a><br/></td></tr>
<tr class="separator:ae875834549b5401b827d6783cd4173bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3195f96fefe71f3c578b0073091f0c26"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a3195f96fefe71f3c578b0073091f0c26">getAmplitude</a> (const <a class="el" href="namespacelcmc_1_1stats.html#a52dbeaa8c5a81665a3c1f1423cd02ede">DoubleVec</a> &amp;mags)</td></tr>
<tr class="memdesc:a3195f96fefe71f3c578b0073091f0c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the light curve amplitude.  <a href="#a3195f96fefe71f3c578b0073091f0c26">More...</a><br/></td></tr>
<tr class="separator:a3195f96fefe71f3c578b0073091f0c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cae20a0308ad0f75ed74ea8641415d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#ad2cae20a0308ad0f75ed74ea8641415d">getSummaryStats</a> (const vector&lt; double &gt; &amp;values, double &amp;mean, double &amp;stddev, const string &amp;statName)</td></tr>
<tr class="memdesc:ad2cae20a0308ad0f75ed74ea8641415d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the mean and standard deviation of a collection of statistics.  <a href="#ad2cae20a0308ad0f75ed74ea8641415d">More...</a><br/></td></tr>
<tr class="separator:ad2cae20a0308ad0f75ed74ea8641415d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2198f51b834ba613ad328945208f86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a8a2198f51b834ba613ad328945208f86">getSummaryStats</a> (const vector&lt; double &gt; &amp;values, double &amp;mean, double &amp;stddev, double &amp;goodFrac, const string &amp;statName)</td></tr>
<tr class="memdesc:a8a2198f51b834ba613ad328945208f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the mean, standard deviation, and definition rate of a collection of statistics.  <a href="#a8a2198f51b834ba613ad328945208f86">More...</a><br/></td></tr>
<tr class="separator:a8a2198f51b834ba613ad328945208f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa837193e0a9d2808b27d0587748d408"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#aaa837193e0a9d2808b27d0587748d408">printStat</a> (FILE *const file, const vector&lt; double &gt; &amp;archive, const string &amp;statName, const string &amp;distribFile)</td></tr>
<tr class="memdesc:aaa837193e0a9d2808b27d0587748d408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a single family of statistics to the specified file.  <a href="#aaa837193e0a9d2808b27d0587748d408">More...</a><br/></td></tr>
<tr class="separator:aaa837193e0a9d2808b27d0587748d408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0570420f9a4f71467f321ce5dea5ba78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a0570420f9a4f71467f321ce5dea5ba78">printStatAlwaysDefined</a> (FILE *const file, const vector&lt; double &gt; &amp;archive, const string &amp;statName, const string &amp;distribFile)</td></tr>
<tr class="memdesc:a0570420f9a4f71467f321ce5dea5ba78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a single family of statistics to the specified file.  <a href="#a0570420f9a4f71467f321ce5dea5ba78">More...</a><br/></td></tr>
<tr class="separator:a0570420f9a4f71467f321ce5dea5ba78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f073b54cb3030d0308fca150229fafd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a4f073b54cb3030d0308fca150229fafd">printStat</a> (FILE *const file, const std::vector&lt; vector&lt; double &gt; &gt; &amp;archive, const string &amp;distribFile)</td></tr>
<tr class="memdesc:a4f073b54cb3030d0308fca150229fafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a set of functions to the specified file.  <a href="#a4f073b54cb3030d0308fca150229fafd">More...</a><br/></td></tr>
<tr class="separator:a4f073b54cb3030d0308fca150229fafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bdfccc2eef2bb3b508466a1d61347f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#ab2bdfccc2eef2bb3b508466a1d61347f">printStat</a> (FILE *const file, const std::vector&lt; vector&lt; double &gt; &gt; &amp;timeArchive, const std::vector&lt; vector&lt; double &gt; &gt; &amp;statArchive, const string &amp;distribFile)</td></tr>
<tr class="memdesc:ab2bdfccc2eef2bb3b508466a1d61347f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a set of functions to the specified file.  <a href="#ab2bdfccc2eef2bb3b508466a1d61347f">More...</a><br/></td></tr>
<tr class="separator:ab2bdfccc2eef2bb3b508466a1d61347f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783811dfe0aecef08c07675fb7a22f2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a783811dfe0aecef08c07675fb7a22f2b">swap</a> (<a class="el" href="classlcmc_1_1stats_1_1_collected_pairs.html">CollectedPairs</a> &amp;a, <a class="el" href="classlcmc_1_1stats_1_1_collected_pairs.html">CollectedPairs</a> &amp;b)</td></tr>
<tr class="memdesc:a783811dfe0aecef08c07675fb7a22f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-throwing swap.  <a href="#a783811dfe0aecef08c07675fb7a22f2b">More...</a><br/></td></tr>
<tr class="separator:a783811dfe0aecef08c07675fb7a22f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa31727b67f2d3621579b5370bbcc6d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#afa31727b67f2d3621579b5370bbcc6d3">doPeak</a> (const vector&lt; double &gt; &amp;times, const vector&lt; double &gt; &amp;mags, bool getCut, bool getPlot, <a class="el" href="classlcmc_1_1stats_1_1_collected_scalars.html">CollectedScalars</a> &amp;cut3, <a class="el" href="classlcmc_1_1stats_1_1_collected_scalars.html">CollectedScalars</a> &amp;cut2, <a class="el" href="classlcmc_1_1stats_1_1_collected_scalars.html">CollectedScalars</a> &amp;cut80, <a class="el" href="classlcmc_1_1stats_1_1_collected_pairs.html">CollectedPairs</a> &amp;peakPlot)</td></tr>
<tr class="memdesc:afa31727b67f2d3621579b5370bbcc6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does all peak-finding related computations for a given light curve.  <a href="#afa31727b67f2d3621579b5370bbcc6d3">More...</a><br/></td></tr>
<tr class="separator:afa31727b67f2d3621579b5370bbcc6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc3219c3f019bcb3b7c116aa0787452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a3bc3219c3f019bcb3b7c116aa0787452">doPeriodogram</a> (const vector&lt; double &gt; &amp;times, const vector&lt; double &gt; &amp;data, bool getPeriod, bool getPlot, <a class="el" href="classlcmc_1_1stats_1_1_collected_scalars.html">CollectedScalars</a> &amp;periods, <a class="el" href="classlcmc_1_1stats_1_1_collected_pairs.html">CollectedPairs</a> &amp;periodograms)</td></tr>
<tr class="memdesc:a3bc3219c3f019bcb3b7c116aa0787452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does all periodogram-related computations for a given light curve.  <a href="#a3bc3219c3f019bcb3b7c116aa0787452">More...</a><br/></td></tr>
<tr class="separator:a3bc3219c3f019bcb3b7c116aa0787452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0098640d6a26f33ac402d685557789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a1d0098640d6a26f33ac402d685557789">swap</a> (<a class="el" href="classlcmc_1_1stats_1_1_collected_scalars.html">CollectedScalars</a> &amp;a, <a class="el" href="classlcmc_1_1stats_1_1_collected_scalars.html">CollectedScalars</a> &amp;b)</td></tr>
<tr class="memdesc:a1d0098640d6a26f33ac402d685557789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-throwing swap.  <a href="#a1d0098640d6a26f33ac402d685557789">More...</a><br/></td></tr>
<tr class="separator:a1d0098640d6a26f33ac402d685557789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738843425449c8133a252436a957f40d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#a738843425449c8133a252436a957f40d">swap</a> (<a class="el" href="classlcmc_1_1stats_1_1_collected_vectors.html">CollectedVectors</a> &amp;a, <a class="el" href="classlcmc_1_1stats_1_1_collected_vectors.html">CollectedVectors</a> &amp;b)</td></tr>
<tr class="memdesc:a738843425449c8133a252436a957f40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-throwing swap.  <a href="#a738843425449c8133a252436a957f40d">More...</a><br/></td></tr>
<tr class="separator:a738843425449c8133a252436a957f40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd43a1b97048229727f568a987c76e1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacelcmc_1_1stats.html#a619f03446471119c2cb3bf4fa5ca1b4a">StatRegistry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelcmc_1_1stats.html#aacd43a1b97048229727f568a987c76e1">getStatRegistry</a> ()</td></tr>
<tr class="memdesc:aacd43a1b97048229727f568a987c76e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a global registry of statistics.  <a href="#aacd43a1b97048229727f568a987c76e1">More...</a><br/></td></tr>
<tr class="separator:aacd43a1b97048229727f568a987c76e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace identifies data types and functions that handle data analysis on simulated light curves. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a4b5a1f3a60aa397d707b7d221d6a034c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacelcmc_1_1stats.html#a4b5a1f3a60aa397d707b7d221d6a034c">lcmc::stats::StatType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used to tell the program which statistics to calculate. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a4b5a1f3a60aa397d707b7d221d6a034ca287262010e6e0b29d1e91f134e817cd6"></a>C1</em>&#160;</td><td class="fielddoc">
<p>Represents the C1 statistic. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4b5a1f3a60aa397d707b7d221d6a034ca16e2c7713481c044411250289e9be9fa"></a>PERIOD</em>&#160;</td><td class="fielddoc">
<p>Represents the period. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4b5a1f3a60aa397d707b7d221d6a034cac013b980d88d361ce0b6a3bd3517e795"></a>PERIODOGRAM</em>&#160;</td><td class="fielddoc">
<p>Represents dumps of periodograms. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4b5a1f3a60aa397d707b7d221d6a034ca1cbc544d527b683464b6c4d27ed86e9d"></a>DMDTCUT</em>&#160;</td><td class="fielddoc">
<p>Represents cuts through &Delta;m&Delta;t plots. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4b5a1f3a60aa397d707b7d221d6a034caab045169d278e7b6b2935ebb829d6974"></a>DMDT</em>&#160;</td><td class="fielddoc">
<p>Represents dumps of &Delta;m&Delta;t plots. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4b5a1f3a60aa397d707b7d221d6a034ca95ed1d3e7d7405c1c9d597798f2b4b21"></a>IACFCUT</em>&#160;</td><td class="fielddoc">
<p>Represents cuts through interpolated ACF plots. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4b5a1f3a60aa397d707b7d221d6a034ca65cdfafd12856d87cd063c2f5f78d041"></a>IACF</em>&#160;</td><td class="fielddoc">
<p>Represents dumps of interpolated ACF plots. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4b5a1f3a60aa397d707b7d221d6a034ca9eee78f67dee89b19c2423037124d2cd"></a>SACFCUT</em>&#160;</td><td class="fielddoc">
<p>Represents cuts through Scargle ACF plots. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4b5a1f3a60aa397d707b7d221d6a034ca3dcb41e35d1599d6bb602a7992b91cfe"></a>SACF</em>&#160;</td><td class="fielddoc">
<p>Represents dumps of Scargle ACF plots. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4b5a1f3a60aa397d707b7d221d6a034cac8c6d4e7d3dee8feba327d72103bed3c"></a>PEAKCUT</em>&#160;</td><td class="fielddoc">
<p>Represents cuts through peak-find plots. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4b5a1f3a60aa397d707b7d221d6a034caaf3d1af1bd8b5d95d66473e62941c324"></a>PEAKFIND</em>&#160;</td><td class="fielddoc">
<p>Represents dumps of peak-find plots. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4b5a1f3a60aa397d707b7d221d6a034cad85ca508a0d9f802af261d70c7f1d914"></a>GPTAU</em>&#160;</td><td class="fielddoc">
<p>Represents the best-fit Gaussian process model. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a60c79dcd216675ddde83c6593b67163e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::autoCorrelation_sp </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>data</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>acfs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the lag-<code>n</code> autocorrelation of the dataset <code>data</code>, using the signal-processing convention. </p>
<p>The interface is deliberately written in C style, for ease of swapping out with an eventual GSL function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data,n</td><td>The dataset to autocorrelate. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acfs</td><td>An array of length <code>n</code> that will contain the lag-0 through lag-(<code>n-1</code>) offsets</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>n</code> &ge; 2</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><img class="formulaInl" alt="$ a_k = \sum_{i = k}^{n-1} x_i x_{i-k} $" src="form_0.png"/>, where <img class="formulaInl" alt="$ a_k $" src="form_1.png"/> denotes <code>acf</code>[k] and <img class="formulaInl" alt="$ x_i $" src="form_2.png"/> denotes <code>data</code>[i]</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>O(<code>n</code><sup>2</sup>) worst-case time </dd></dl>
<dl class="section user"><dt></dt><dd>O(<code>n</code> log <code>n</code>) best-case time</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlcmc_1_1stats_1_1except_1_1_not_enough_data.html" title="This exception is thrown if a range does not contain enough data to calculate the desired statistic...">lcmc::stats::except::NotEnoughData</a></td><td>Thrown if <code>n</code> &lt; 2 </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>Thrown if the internal calculations produce an error. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if there is not enough memory to compute the autocorrelation function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The function parameters are unchanged in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="afc58172e2cb4a86a72d78b2e17bc69bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::autoCorrelation_stat </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>data</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>acfs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the lag-<code>n</code> autocorrelation of the dataset <code>data</code>, using the statistical analysis convention. </p>
<p>The interface is deliberately written in C style, for ease of swapping out with an eventual GSL function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data,n</td><td>The dataset to autocorrelate. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acfs</td><td>An array of length <code>n</code> that will contain the lag-0 through lag-(<code>n-1</code>) offsets</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>n</code> &ge; 2</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><p class="formulaDsp">
<img class="formulaDsp" alt="\[ a_k = \frac{\sum_{i = k}^{n-1} (x_{i} - \hat\mu) (x_{i-k} - \hat\mu)} {\sum_{i = k}^{n-1} (x_{i} - \hat\mu) (x_{i} - \hat\mu)} \]" src="form_3.png"/>
</p>
 where where <img class="formulaInl" alt="$ a_k $" src="form_1.png"/> denotes <code>acf</code>[k], <img class="formulaInl" alt="$ x_i $" src="form_2.png"/> denotes <code>data</code>[i], and <img class="formulaInl" alt="$ \hat\mu $" src="form_4.png"/> is the sample mean of <code>data</code>.</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>O(<code>n</code><sup>2</sup>) worst-case time </dd></dl>
<dl class="section user"><dt></dt><dd>O(<code>n</code> log <code>n</code>) best-case time</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlcmc_1_1stats_1_1except_1_1_not_enough_data.html" title="This exception is thrown if a range does not contain enough data to calculate the desired statistic...">lcmc::stats::except::NotEnoughData</a></td><td>Thrown if <code>n</code> &lt; 2 </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>Thrown if the internal calculations produce an error. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if there is not enough memory to compute the autocorrelation function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The function parameters are unchanged in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0f582da5d0dfcbf71bb31bd1c63d805"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double lcmc::stats::cutFunction </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first location on a grid where a predicate is true. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryPredicate</td><td>The type of condition to test. Must be a <a href="http://www.sgi.com/tech/stl/Predicate.html">unary predicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The position grid on which to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to test against cut. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>The condition that must be satisfied by the return value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value <code>pos</code>[i] at which <code>pred(func[i])</code> is first true, or NaN if <code>pred(x)</code> is false for all x &isin; <code>func</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>pos.size()</code> = <code>func.size()</code> </dd>
<dd>
<code>pos</code> does not contain NaNs </dd>
<dd>
<code>func</code> may contain NaNs</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>O(N) time, where N = <code>func.size()</code> </dd></dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>If <code>pred</code> throws exceptions, then <a class="el" href="namespacelcmc_1_1stats.html#ae0f582da5d0dfcbf71bb31bd1c63d805" title="Finds the first location on a grid where a predicate is true. ">cutFunction()</a> has the same exception guarantee as <code>pred</code>. Otherwise, does not throw exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a7797cbec7ef870b86f9850d9a296b8d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double lcmc::stats::cutFunctionReverse </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the last location on a grid where a predicate is true. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryPredicate</td><td>The type of condition to test. Must be a <a href="http://www.sgi.com/tech/stl/Predicate.html">unary predicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The position grid on which to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to test against cut. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>The condition that must be satisfied by the return value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value <code>pos</code>[i] at which <code>pred(func[i])</code> is last true, or NaN if <code>pred(x)</code> is false for all x &isin; <code>func</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>pos.size()</code> = <code>func.size()</code> </dd>
<dd>
<code>pos</code> does not contain NaNs </dd>
<dd>
<code>func</code> may contain NaNs</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>O(N) time, where N = <code>func.size()</code> </dd></dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>If <code>pred</code> throws exceptions, then <a class="el" href="namespacelcmc_1_1stats.html#a7797cbec7ef870b86f9850d9a296b8d8" title="Finds the last location on a grid where a predicate is true. ">cutFunctionReverse()</a> has the same exception guarantee as <code>pred</code>. Otherwise, does not throw exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a6861bfef2e6748dffcc03f7bc3f6885c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::doAcf </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const vector&lt; double &gt; &amp;, const vector&lt; double &gt; &amp;, double, size_t, vector&lt; double &gt; &amp;)&#160;</td>
          <td class="paramname"><em>acfFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getCut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getPlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedScalars &amp;&#160;</td>
          <td class="paramname"><em>cut9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedScalars &amp;&#160;</td>
          <td class="paramname"><em>cut4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedScalars &amp;&#160;</td>
          <td class="paramname"><em>cut2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedPairs &amp;&#160;</td>
          <td class="paramname"><em>acfPlot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does all ACF-related computations for a given light curve. </p>
<p>The flavor of ACF is specified using a callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">times</td><td>The times at which the light curve was sampled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The values of the light curve </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acfFunc</td><td>Function for calculating the autocorrelation function. <code>acfFunc</code> takes, in order, the times of the light curve, the values of the light curve, the time step between lag values, the number of lag values, and an output vector to store the ACF. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getCut</td><td>Flag indicating that cuts through the the ACF should be extracted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getPlot</td><td>Flag indicating that the ACF should be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cut9</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the time offset at which the ACF crosses 1/9. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cut4</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the time offset at which the ACF crosses 1/4. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cut2</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the time offset at which the ACF crosses 1/2. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acfPlot</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the ACF.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>times.size()</code> = <code>data.size()</code> </dd>
<dd>
Neither <code>times</code> nor <code>data</code> may contain NaNs</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>if <code>getCut</code>, then new elements are appended to <code>cut9</code>, <code>cut4</code>, and <code>cut2</code>. If any of the cuts are undefined, NaN is appended to the corresponding collection. </dd>
<dd>
if <code>getPlot</code>, then a new element is appended to <code>acfPlot</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if there is not enough memory to store more statistics. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown if <code>times</code> and <code>data</code> do not have matching lengths or if <code>times</code> or <code>data</code> contains NaNs. </td></tr>
    <tr><td class="paramname"><a class="el" href="classlcmc_1_1stats_1_1except_1_1_not_enough_data.html" title="This exception is thrown if a range does not contain enough data to calculate the desired statistic...">lcmc::stats::except::NotEnoughData</a></td><td>Thrown if <code>times</code> and <code>data</code> are too short to calculate the desired statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Additional exceptions may be thrown by <code>acfFunc</code>.</dd></dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The program is in a consistent state in the event of an exception, provided <code>acfFunc</code> offers at least the basic exception guarantee. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Reimplement using an iterator adapter for faster performance </dd></dl>

</div>
</div>
<a class="anchor" id="abcbe18e1119d82ef1e25de1c9993e0fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::doDmdt </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>mags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getCut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getPlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedScalars &amp;&#160;</td>
          <td class="paramname"><em>cut50Amp3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedScalars &amp;&#160;</td>
          <td class="paramname"><em>cut50Amp2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedScalars &amp;&#160;</td>
          <td class="paramname"><em>cut90Amp3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedScalars &amp;&#160;</td>
          <td class="paramname"><em>cut90Amp2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedPairs &amp;&#160;</td>
          <td class="paramname"><em>dmdtMed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does all &Delta;m&Delta;t-related computations for a given light curve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">times</td><td>The times at which the light curve was sampled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mags</td><td>The values of the light curve </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getCut</td><td>Flag indicating that cuts through the the &Delta;m&Delta;t quantiles should be extracted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getPlot</td><td>Flag indicating that the &Delta;m&Delta;t quantiles should be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cut50Amp3</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the &Delta;t value at which the 50th percentile of &Delta;m crosses 1/3 the amplitude. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cut50Amp2</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the &Delta;t value at which the 50th percentile of &Delta;m crosses 1/2 the amplitude. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cut90Amp3</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the &Delta;t value at which the 90th percentile of &Delta;m crosses 1/3 the amplitude. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cut90Amp2</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the &Delta;t value at which the 90th percentile of &Delta;m crosses 1/2 the amplitude. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dmdtMed</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the median value of &Delta;m as a function of &Delta;t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>times.size()</code> = <code>mags.size()</code> </dd>
<dd>
Neither <code>times</code> nor <code>mags</code> may contain NaNs</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>if <code>getCut</code>, then new elements are appended to <code>cut50Amp3</code>, <code>cut50Amp2</code>, <code>cut90Amp3</code>, and <code>cut90Amp2</code>. If any of the cuts are undefined, NaN is appended to the corresponding collection. </dd>
<dd>
if <code>getPlot</code>, then a new element is appended to <code>dmdtMed</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if there is not enough memory to store more statistics. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown if <code>times</code> and <code>mags</code> do not have matching lengths or if <code>times</code> or <code>data</code> contains NaNs. </td></tr>
    <tr><td class="paramname"><a class="el" href="classlcmc_1_1stats_1_1except_1_1_not_enough_data.html" title="This exception is thrown if a range does not contain enough data to calculate the desired statistic...">lcmc::stats::except::NotEnoughData</a></td><td>Thrown if <code>times</code> and <code>mags</code> are too short to calculate the desired statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The program is in a consistent state in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a15f720937490ca2df81c56324f924bbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::doGaussFit </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getGp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>trueTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedScalars &amp;&#160;</td>
          <td class="paramname"><em>timescales</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedScalars &amp;&#160;</td>
          <td class="paramname"><em>timeErrors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedScalars &amp;&#160;</td>
          <td class="paramname"><em>normDevs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does all GP-related computations for a given light curve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">times</td><td>The times at which the light curve was sampled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The values of the light curve </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getGp</td><td>Flag indicating that the best-fit timescale should be extracted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trueTime</td><td>The value of the true time scale. NaN if not available. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timescales</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the best-fit timescale, if any. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timeErrors</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the uncertainty on the best-fit timescale, if any. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">normDevs</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the normalized deviation of the best-fit time scale from the true time scale, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>times.size()</code> = <code>data.size()</code> </dd>
<dd>
Neither <code>times</code> nor <code>data</code> may contain NaNs</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>if <code>getGp</code>, then a new element is appended to each of <code>timescales</code>, <code>timeErrors</code>, and <code>normDev</code>. If no value is found, the appended value is NaN.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if there is not enough memory to store more statistics. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown if <code>times</code> and <code>data</code> do not have matching lengths or if <code>times</code> or <code>data</code> contains NaNs. </td></tr>
    <tr><td class="paramname"><a class="el" href="classlcmc_1_1stats_1_1except_1_1_not_enough_data.html" title="This exception is thrown if a range does not contain enough data to calculate the desired statistic...">lcmc::stats::except::NotEnoughData</a></td><td>Thrown if <code>times</code> and <code>data</code> are too short to calculate the desired statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The program is in a consistent state in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="afa31727b67f2d3621579b5370bbcc6d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::doPeak </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>mags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getCut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getPlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedScalars &amp;&#160;</td>
          <td class="paramname"><em>cut3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedScalars &amp;&#160;</td>
          <td class="paramname"><em>cut2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedScalars &amp;&#160;</td>
          <td class="paramname"><em>cut80</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedPairs &amp;&#160;</td>
          <td class="paramname"><em>peakPlot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does all peak-finding related computations for a given light curve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">times</td><td>The times at which the light curve was sampled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mags</td><td>The values of the light curve </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getCut</td><td>Flag indicating that cuts through the the peak-finding curve should be extracted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getPlot</td><td>Flag indicating that the peak-finding curve should be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cut3</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the time offset at which the peak-finding curve crosses 1/3 of the light curve amplitude. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cut2</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the time offset at which the peak-finding curve crosses 1/2 of the light curve amplitude. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cut80</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the time offset at which the peak-finding curve crosses 80% of its maximum value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">peakPlot</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the peak-finding curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>times.size()</code> = <code>mags.size()</code> </dd>
<dd>
Neither <code>times</code> nor <code>mags</code> may contain NaNs</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>if <code>getCut</code>, then new elements are appended to <code>cut3</code>, <code>cut2</code>, and <code>cut80</code>. If the cut is undefined, NaN is appended. </dd>
<dd>
if <code>getPlot</code>, then a new element is appended to <code>peakPlot</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if there is not enough memory to store more statistics. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown if <code>times</code> and <code>mags</code> do not have matching lengths or if <code>times</code> or <code>data</code> contains NaNs. </td></tr>
    <tr><td class="paramname"><a class="el" href="classlcmc_1_1stats_1_1except_1_1_not_enough_data.html" title="This exception is thrown if a range does not contain enough data to calculate the desired statistic...">lcmc::stats::except::NotEnoughData</a></td><td>Thrown if <code>times</code> and <code>mags</code> are too short to calculate the desired statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The program is in a consistent state in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bc3219c3f019bcb3b7c116aa0787452"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::doPeriodogram </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getPeriod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getPlot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedScalars &amp;&#160;</td>
          <td class="paramname"><em>periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedPairs &amp;&#160;</td>
          <td class="paramname"><em>periodograms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does all periodogram-related computations for a given light curve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">times</td><td>The times at which the light curve was sampled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The values of the light curve </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getPeriod</td><td>Flag indicating that the best period (having &lt;1% FAP in the case of Gaussian white noise) should be extracted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getPlot</td><td>Flag indicating that the periodograms should be stored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">periods</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the period, if any. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">periodograms</td><td>The <a class="el" href="classlcmc_1_1stats_1_1_named_collection.html" title="Abstract base class defining infrastructure used by statistic collections. ">NamedCollection</a> in which to record the periodograms.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>times.size()</code> = <code>data.size()</code> </dd>
<dd>
Neither <code>times</code> nor <code>data</code> may contain NaNs</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>if <code>getPeriod</code>, then a new element is appended to <code>periods</code>. If no significant period is found, the appended value is NaN. </dd>
<dd>
if <code>getPlot</code>, then a new element is appended to <code>periodograms</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if there is not enough memory to store more statistics. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown if <code>times</code> and <code>data</code> do not have matching lengths or if <code>times</code> or <code>data</code> contains NaNs. </td></tr>
    <tr><td class="paramname"><a class="el" href="classlcmc_1_1stats_1_1except_1_1_not_enough_data.html" title="This exception is thrown if a range does not contain enough data to calculate the desired statistic...">lcmc::stats::except::NotEnoughData</a></td><td>Thrown if <code>times</code> and <code>data</code> are too short to calculate the desired statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The program is in a consistent state in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a697c54a73393b6f104833494cb7a5a45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::fitGaussGp </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>timescale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>timeError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the best fit solution to a squared exponential Gaussian process model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">times</td><td>The times at which the light curve was sampled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The values of the light curve (typically fluxes or magnitudes) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timescale</td><td>The best-fit value of the model timescale </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timeError</td><td>The estimated uncertainty on the model timescale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>times</code> contains at least two unique values </dd>
<dd>
<code>times.size()</code> = <code>data.size()</code> </dd>
<dd>
for all i, <code>data</code>[i] is the measurement taken at <code>time</code>[i] </dd>
<dd>
Neither <code>times</code> nor <code>data</code> may contain NaNs</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>timescale</code> and <code>timeError</code> contain the best-fit estimate of the correlation timescale for a Gaussian process model </dd>
<dd>
<code>timescale</code> &gt; 0 </dd>
<dd>
<code>timeError</code> &gt; 0</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>O(N<sup>3</sup>) time, where N = <code>times.size()</code> </dd></dl>
<dl class="section user"><dt></dt><dd>O(N<sup>2</sup>) memory</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlcmc_1_1utils_1_1except_1_1_unexpected_nan.html" title="This exception is thrown if any calculation finds a NaN value where none is allowed. ">lcmc::utils::except::UnexpectedNan</a></td><td>Thrown if there are any NaN values present in <code>times</code> or <code>data</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classlcmc_1_1stats_1_1except_1_1_not_enough_data.html" title="This exception is thrown if a range does not contain enough data to calculate the desired statistic...">lcmc::stats::except::NotEnoughData</a></td><td>Thrown if <code>times</code> and <code>data</code> do not have at least two values. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown if <code>times</code> and <code>data</code> do not have the same length. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>Thrown if the internal calculations produce an error. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if there is not enough memory to fit the model.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The program is in a consistent state in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a3195f96fefe71f3c578b0073091f0c26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double lcmc::stats::getAmplitude </td>
          <td>(</td>
          <td class="paramtype">const DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>mags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the light curve amplitude. </p>
<p>The amplitude is defined as the range between the 5th and 95th percentiles. This definition is relatively insensitive to outliers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mags</td><td>A vector of magnitudes from which to calculate the amplitude.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amplitude.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>mags</code> contains at least two finite values </dd>
<dd>
<code>mags</code> may contain NaNs</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>O(N log N) time, where N = <code>mags.size()</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if not enough memory to calculate amplitude </td></tr>
    <tr><td class="paramname"><a class="el" href="classlcmc_1_1stats_1_1except_1_1_not_enough_data.html" title="This exception is thrown if a range does not contain enough data to calculate the desired statistic...">lcmc::stats::except::NotEnoughData</a></td><td>Thrown if <code>mags</code> does not have enough values to calculate an amplitude</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>Program state is unchanged in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="ae875834549b5401b827d6783cd4173bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double lcmc::stats::getC1 </td>
          <td>(</td>
          <td class="paramtype">const DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>mags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the modified C1 statistic. </p>
<p>The statistic is identical to that presented in <a class="el" href="citelist.html#CITEREF_RotorCtts">[1]</a>, except that the minimum and maximum magnitude have been replaced with the 5th and 95th percentile, respectively. This change makes the C1 statistic much less sensitive to outliers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mags</td><td>A vector of magnitudes from which to calculate C1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The C1 statistic.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>mags</code> contains at least three finite values </dd>
<dd>
<code>mags</code> contains at least two distinct finite values</dd>
<dd>
<code>mags</code> may contain NaNs</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>O(N log N) time, where N = <code>mags.size()</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if not enough memory to calculate C1 </td></tr>
    <tr><td class="paramname"><a class="el" href="classlcmc_1_1stats_1_1except_1_1_undefined.html" title="This exception is thrown if a statistic cannot be calculated from the available data. ">lcmc::stats::except::Undefined</a></td><td>Thrown if C1 is undefined because <code>mags</code> has no variability </td></tr>
    <tr><td class="paramname"><a class="el" href="classlcmc_1_1stats_1_1except_1_1_not_enough_data.html" title="This exception is thrown if a range does not contain enough data to calculate the desired statistic...">lcmc::stats::except::NotEnoughData</a></td><td>Thrown if <code>mags</code> does not have enough values to calculate C1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>Program state is unchanged in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="aacd43a1b97048229727f568a987c76e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacelcmc_1_1stats.html#a619f03446471119c2cb3bf4fa5ca1b4a">StatRegistry</a>&amp; lcmc::stats::getStatRegistry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a global registry of statistics. </p>
<dl class="section return"><dt>Returns</dt><dd>The registry.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if there is not enough memory to create the registry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The program state is unchanged in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2cae20a0308ad0f75ed74ea8641415d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::getSummaryStats </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>stddev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>statName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the mean and standard deviation of a collection of statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>The statistics to be summarized. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean</td><td>The mean of the statistics. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stddev</td><td>The standard deviation of the statistics. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statName</td><td>The name of the statistic, for error messages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>mean</code> and <code>stddev</code> ignore any NaNs present in <code>values</code>. </dd>
<dd>
If there are no non-NaN elements in <code>values</code>, <code>mean</code> equals NaN </dd>
<dd>
If there are less than two non-NaN elements in <code>values</code>, <code>stddev</code> equals NaN</dd></dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>Does not throw exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a2198f51b834ba613ad328945208f86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::getSummaryStats </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>stddev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>goodFrac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>statName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the mean, standard deviation, and definition rate of a collection of statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>The statistics to be summarized. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean</td><td>The mean of the statistics. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stddev</td><td>The standard deviation of the statistics. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">goodFrac</td><td>The fraction of measurements that are finite values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statName</td><td>The name of the statistic, for error messages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>mean</code> and <code>stddev</code> ignore any NaNs present in <code>values</code>. </dd>
<dd>
If there are no non-NaN elements in <code>values</code>, <code>mean</code> equals NaN </dd>
<dd>
If there are less than two non-NaN elements in <code>values</code>, <code>stddev</code> equals NaN </dd>
<dd>
If there are no elements in <code>values</code>, <code>goodFrac</code> equals 0</dd></dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>Does not throw exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa837193e0a9d2808b27d0587748d408"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::printStat </td>
          <td>(</td>
          <td class="paramtype">FILE *const&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>statName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>distribFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a single family of statistics to the specified file. </p>
<p>The function will print, in order: the mean of the statistic, the standard deviation of the statistic, the fraction of times each statistic was defined, and the name of a file containing the distribution of the statistics. The row is in tab-delimited format, except that the mean and standard deviation are separated by a ± sign for improved readability.</p>
<p>This function differs from <a class="el" href="namespacelcmc_1_1stats.html#a0570420f9a4f71467f321ce5dea5ba78" title="Prints a single family of statistics to the specified file. ">printStatAlwaysDefined()</a> only in that the latter does not print the number of times each statistic had a value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>An open file handle representing the text file to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">archive</td><td>The statistics to summarize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statName</td><td>The name of the statistic to use for error messages. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distribFile</td><td>The prefix identifying the distribution file as being for this particular statistic.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Thrown if there are difficulties writing to <code>file</code> </td></tr>
    <tr><td class="paramname">kpfutils::except::FileIo</td><td>Thrown if there are difficulties writing to <code>distribFile</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The program is in a consistent state in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f073b54cb3030d0308fca150229fafd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::printStat </td>
          <td>(</td>
          <td class="paramtype">FILE *const&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>distribFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a set of functions to the specified file. </p>
<p>Prints a single family of statistics to the specified file.</p>
<p>The function will print only the name of a file containing the distribution of the functions. The row is in tab-delimited format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>An open file handle representing the text file to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">archive</td><td>The statistic to print. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distribFile</td><td>The prefix identifying the distribution file as being for this particular statistic.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Thrown if there are difficulties writing to <code>file</code> </td></tr>
    <tr><td class="paramname">kpfutils::except::FileIo</td><td>Thrown if there are difficulties writing to <code>distribFile</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The program is in a consistent state in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2bdfccc2eef2bb3b508466a1d61347f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::printStat </td>
          <td>(</td>
          <td class="paramtype">FILE *const&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeArchive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>statArchive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>distribFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a set of functions to the specified file. </p>
<p>The function will print only the name of a file containing the distribution of the functions. The row is in tab-delimited format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>An open file handle representing the text file to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeArchive</td><td>The times of the functions to print. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statArchive</td><td>The values of the functions to print. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distribFile</td><td>The prefix identifying the distribution file as being for this particular statistic.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Thrown if there are difficulties writing to <code>file</code> </td></tr>
    <tr><td class="paramname">kpfutils::except::FileIo</td><td>Thrown if there are difficulties writing to <code>distribFile</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The program is in a consistent state in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a0570420f9a4f71467f321ce5dea5ba78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::printStatAlwaysDefined </td>
          <td>(</td>
          <td class="paramtype">FILE *const&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>statName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>distribFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a single family of statistics to the specified file. </p>
<p>The function will print, in order: the mean of the statistic, the standard deviation of the statistic, and the name of a file containing the distribution of the statistics. The row is in tab-delimited format, except that the mean and standard deviation are separated by a ± sign for improved readability.</p>
<p>This function differs from <a class="el" href="namespacelcmc_1_1stats.html#aaa837193e0a9d2808b27d0587748d408" title="Prints a single family of statistics to the specified file. ">printStat()</a> only in that the latter also prints the number of times each statistic had a value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>An open file handle representing the text file to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">archive</td><td>The statistics to summarize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">statName</td><td>The name of the statistic to use for error messages. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distribFile</td><td>The prefix identifying the distribution file as being for this particular statistic.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Thrown if there are difficulties writing to <code>file</code> </td></tr>
    <tr><td class="paramname">kpfutils::except::FileIo</td><td>Thrown if there are difficulties writing to <code>distribFile</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The program is in a consistent state in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a352e5fc1c24fefa5c94a4ff7b7058344"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::rmsVsTAllPairs </td>
          <td>(</td>
          <td class="paramtype">const DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>fluxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>timeSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>rmsValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the RMS binned over ever-larger subintervals of the data. </p>
<p><a class="el" href="namespacelcmc_1_1stats.html#a352e5fc1c24fefa5c94a4ff7b7058344" title="Calculates the RMS binned over ever-larger subintervals of the data. ">rmsVsTAllPairs()</a> considers all subintervals of the data set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">times</td><td>Times at which data were taken </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fluxes</td><td>Flux measurements of a source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timeSteps</td><td>A list of the lengths of all subintervals </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rmsValues</td><td>A list of the RMS over each subinterval</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>times</code> contains at least two unique values </dd>
<dd>
<code>times</code> is sorted in ascending order </dd>
<dd>
<code>fluxes</code> is of the same length as times </dd>
<dd>
<code>fluxes</code>[i] is the flux of the source at <code>times</code>[i], for all i</dd>
<dd>
<code>times</code> does not contain NaNs </dd>
<dd>
<code>fluxes</code> does not contain NaNs </dd>
<dd>
<code>timeSteps</code> does not contain NaNs</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>timeSteps</code> is sorted in ascending order </dd>
<dd>
if N = <code>times.size()</code>, <code>timeSteps.size()</code> = <code>rmsValues.size()</code> = <img class="formulaInl" alt="$ \binom{N}{2} $" src="form_5.png"/></dd></dl>
<dl class="section user"><dt>Performance</dt><dd>O(N<sup>3</sup>) time, where N = times.size()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if there is not enough memory to do the calculations. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown if <code>times</code> is insufficiently long or if <code>fluxes</code> has a different length from <code>times</code> </td></tr>
    <tr><td class="paramname">kpfutils::except::NotSorted</td><td>Thrown if <code>times</code> is unsorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The function arguments are unchanged in the event of an exception.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>Reduce to O(N<sup>2</sup>) time through dynamic programming </dd></dl>

</div>
</div>
<a class="anchor" id="a9bce18a560b85763c1d68b4751ba1106"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::rmsVsTRooted </td>
          <td>(</td>
          <td class="paramtype">const DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>fluxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>timeSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>rmsValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the RMS binned over ever-larger subintervals of the data. </p>
<p><a class="el" href="namespacelcmc_1_1stats.html#a9bce18a560b85763c1d68b4751ba1106" title="Calculates the RMS binned over ever-larger subintervals of the data. ">rmsVsTRooted()</a> considers only subintervals from the first data point to some later point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">times</td><td>Times at which data were taken </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fluxes</td><td>Flux measurements of a source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timeSteps</td><td>A list of the lengths of all subintervals </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rmsValues</td><td>A list of the RMS over each subinterval</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>times.size()</code> &ge; 2 </dd>
<dd>
<code>fluxes.size()</code> = <code>times.size()</code> </dd>
<dd>
<code>times</code> is sorted in ascending order </dd>
<dd>
<code>fluxes</code>[i] is the flux of the source at <code>times</code>[i], for all i</dd>
<dd>
<code>times</code> does not contain NaNs </dd>
<dd>
<code>fluxes</code> does not contain NaNs </dd>
<dd>
<code>timeSteps</code> does not contain NaNs</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>timeSteps</code> is sorted in ascending order </dd>
<dd>
if N = <code>times.size()</code>, <code>timeSteps.size()</code> = <code>rmsValues.size()</code> = N-1</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>O(N<sup>2</sup>) time, where N = <code>times.size()</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Thrown if there is not enough memory to do the calculations. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown if <code>times</code> is insufficiently long or if <code>fluxes</code> has a different length from <code>times</code> </td></tr>
    <tr><td class="paramname">kpfutils::except::NotSorted</td><td>Thrown if <code>times</code> is unsorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The function arguments are unchanged in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a74738a268310228387125a0d85bac3d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::scargleAdapter </td>
          <td>(</td>
          <td class="paramtype">const DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleVec &amp;&#160;</td>
          <td class="paramname"><em>acfs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for calculating the Scargle ACF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">times</td><td>Times at which data were taken </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data (typically fluxes or magnitudes) measured at each time </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offStep,nOffsets</td><td>The spacing and number of grid points over which the ACF should be calculated. The grid will run from lags of 0 to (<code>nOffsets</code>-1)*<code>offStep</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">acfs</td><td>The value of the autocorrelation function at each offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The program is in a consistent state in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a8dfd65ff4f2d027c2db83ceae91760d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::squareAmpHalfComplex </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hcArr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes the squared amplitude of a half-complex vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hcArr</td><td>A vector assumed to be in half-complex format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The length of <code>hcArr</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>n</code> &gt; 0</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>hcArr</code> is modified in place</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Thrown if <code>n</code> &le; 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>The function parameters are unchanged in the event of an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a783811dfe0aecef08c07675fb7a22f2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::swap </td>
          <td>(</td>
          <td class="paramtype">CollectedPairs &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedPairs &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-throwing swap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a,b</td><td>The collections to exchange contents.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The data previously contained in <code>a</code> is now stored in <code>b</code>, and vice versa. All names are switched as well.</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>Constant time</dd></dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>Does not throw exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d0098640d6a26f33ac402d685557789"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::swap </td>
          <td>(</td>
          <td class="paramtype">CollectedScalars &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedScalars &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-throwing swap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a,b</td><td>The collections to exchange contents.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The data previously contained in <code>a</code> is now stored in <code>b</code>, and vice versa. All names are switched as well.</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>Constant time</dd></dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>Does not throw exceptions. </dd></dl>

</div>
</div>
<a class="anchor" id="a738843425449c8133a252436a957f40d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcmc::stats::swap </td>
          <td>(</td>
          <td class="paramtype">CollectedVectors &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CollectedVectors &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-throwing swap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a,b</td><td>The collections to exchange contents.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The data previously contained in <code>a</code> is now stored in <code>b</code>, and vice versa. All names are switched as well.</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>Constant time</dd></dl>
<dl class="section user"><dt>Exception Guarantee</dt><dd>Does not throw exceptions. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelcmc.html">lcmc</a></li><li class="navelem"><a class="el" href="namespacelcmc_1_1stats.html">stats</a></li>
    <li class="footer">Generated on Mon Aug 18 2014 19:21:41 for Lightcurve MC by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
